# Introduction
```{r}
weather_features <- read.csv("weather_features.csv")
dim(weather_features)
```

`weather_features.csv` contains hourly weather data from 2015 to 2018 for 5 major cities in Spain.

```{r}
df <- data.frame(
  Column = colnames(weather_features),
  Description = c("datetime index localized to CET", 
                  "name of city (Barcelona, Bilbao, Madrid, Seville, Valencia)",
                  "temperature (K)", 
                  "minimum temperature (K)",
                  "maximum temperature (K)",
                  "pressure (hPa)",
                  "humidity (%)",
                  "wind speed (m/s)",
                  "wind direction (degrees)",
                  "rain in last hour (mm)",
                  "rain in last 3 hours (mm)",
                  "snow in last 3 hours (mm)",
                  "cloud cover (%)",
                  "weather description - code",
                  "weather description - short",
                  "weather description - long",
                  "weather icon")
)
knitr::kable(df, format = "markdown")
```


# Missing Values
```{r}
sapply(weather_features, function(col) 
  { sum(sapply(col, function(x) {
    (is.na(x)) + (x == "")
  })) })
```

Data has no blank or NA cells in any of the columns. Next, we check that there are no missing rows.  
Since we have hourly data for 3 regular and 1 leap year, we expect there to be $24 \times 365 \times 4 + 24 = 35064$ unique datetime indices.
```{r}
dates_occurences <- table(weather_features$dt_iso)
length(dates_occurences)
```
This matches our expectations.

Since we have 5 cities, we expect each datetime index to appear 5 times. This means a total of $35064 \times 5 = 175320$ rows. However, our data has 178396 rows.
```{r}
sum(sapply(dates_occurences, function(date) { date < 5 }))
```
This indicates that we have no missing rows. 


# Partition Based on City
However,
```{r}
sum(sapply(dates_occurences, function(date) { date > 5 }))
```
shows that we have 2550 of the datetime indices have been repeated at least once.

To fix this, we first create separate data frames for each city, then use the datetime index to remove duplicates.
```{r}
library(dplyr)
Barcelona <- weather_features[, weather_features$city_name == "Barcelona"]
Bilbao <- weather_features[, weather_features$city_name == "Bilbao"]
Madrid <- weather_features[, weather_features$city_name == "Madrid"]
Seville <- weather_features[, weather_features$city_name == "Seville"]
Valencia <- weather_features[, weather_features$city_name == "Valencia"]

sapply(c(Barcelona, Bilbao, Madrid, Seville, Valencia), function(df) {
  df <- df %>% distinct(dt_iso, .keep_all = TRUE)
})
```

#################################################################################################################################3

But wait! using distinct with and without dt_iso parameter has different results! Why?
```{r}
library(dplyr)
Valencia <- weather_features[weather_features$city_name == "Valencia", ]
dim(Valencia)
df1 <- Valencia %>% distinct()
df2 <- Valencia %>% distinct(dt_iso, .keep_all = TRUE)
dim(df1)
dim(df2)
```

```{r}
length(unique(Valencia$dt_iso))
```



